Perfect! Let’s build a **complete playbook for bitwise operations**, structured step by step so you can **understand, practice, and gain muscle memory**. I’ll divide it into **concepts with examples**, and **practice problems** at the end.

---

# **Bitwise Operations Playbook**

---

## **1. Introduction**

Bitwise operations are operations that directly manipulate **individual bits** of integers.
They are fast, memory-efficient, and often used in **competitive programming, low-level programming, and optimization problems**.

Bitwise operations work on the binary representation of numbers.

Example:

```
a = 5  # 0101 in binary
b = 3  # 0011 in binary
```

---

## **2. Bitwise Operators**

### **2.1 AND (`&`)**

* **Operation**: Returns `1` if both corresponding bits are `1`, else `0`.

```
a = 5  # 0101
b = 3  # 0011
a & b  # 0001 -> 1
```

**Use case:** Check if a bit is set.

```python
if a & 1:   # Check if least significant bit is 1
    print("LSB is 1")
```

---

### **2.2 OR (`|`)**

* **Operation**: Returns `1` if **any one** of the corresponding bits is `1`.

```
a = 5  # 0101
b = 3  # 0011
a | b  # 0111 -> 7
```

**Use case:** Set specific bits to `1`.

```python
a = 5
a = a | 2  # Set 2nd LSB
```

---

### **2.3 XOR (`^`)**

* **Operation**: Returns `1` if bits are **different**.

```
a = 5  # 0101
b = 3  # 0011
a ^ b  # 0110 -> 6
```

**Use cases:**

* Swap two numbers without a temporary variable:

```python
x = 10
y = 7
x = x ^ y
y = x ^ y
x = x ^ y
```

* Find the **unique element** in an array where all others appear twice.

---

### **2.4 NOT (`~`)**

* **Operation**: Flips all bits (`1` → `0`, `0` → `1`).

```
a = 5  # 0101
~a     # 1010 (in 2's complement, -6 in decimal)
```

**Note:** Python stores negative numbers in **infinite 2’s complement**, so `~a = -a - 1`.

---

### **2.5 Left Shift (`<<`)**

* **Operation**: Shift bits to the left by `n` positions; fills 0 from the right.

```
a = 5      # 0101
a << 1     # 1010 -> 10
a << 2     # 10100 -> 20
```

**Use case:** Multiply by powers of 2.

```python
x << n  # x * (2**n)
```

---

### **2.6 Right Shift (`>>`)**

* **Operation**: Shift bits to the right by `n` positions.

```
a = 20     # 10100
a >> 1     # 01010 -> 10
a >> 2     # 00101 -> 5
```

**Use case:** Divide by powers of 2 (integer division).

---

## **3. Common Bitwise Tricks**

1. **Check if a number is even or odd**:

```python
if n & 1:
    print("Odd")
else:
    print("Even")
```

2. **Get the rightmost set bit**:

```python
n & -n
```

3. **Turn off the rightmost set bit**:

```python
n = n & (n-1)
```

4. **Count number of set bits**:

```python
count = 0
while n:
    n &= n-1
    count += 1
```

5. **Check if a number is power of two**:

```python
n > 0 and (n & (n-1)) == 0
```

6. **Swap two numbers without temp**:

```python
x ^= y
y ^= x
x ^= y
```

---

## **4. Bit Masks**

* A **bitmask** is a number used to **manipulate bits selectively**.
* Example: Set, clear, or toggle a particular bit.

```python
# Set 3rd bit
n |= (1 << 2)

# Clear 3rd bit
n &= ~(1 << 2)

# Toggle 3rd bit
n ^= (1 << 2)
```

---

## **5. Advanced Applications**

1. **Subset generation using bits**

```python
nums = [1,2,3]
n = len(nums)
for mask in range(1<<n):
    subset = [nums[i] for i in range(n) if mask & (1<<i)]
```

2. **Gray Code generation**

* Gray code: consecutive numbers differ by **1 bit**

```python
gray = i ^ (i >> 1)
```

3. **Finding single number in array**

* Given array where all elements appear twice except one:

```python
res = 0
for num in arr:
    res ^= num
```

---

## **6. Bitwise Practice Problems**

### **Level 1: Basic**

1. Check if a number is even or odd using bitwise operators.
2. Swap two numbers without using a temporary variable.
3. Count the number of set bits in a number.
4. Turn off the rightmost set bit of a number.
5. Check if a number is power of two.

### **Level 2: Intermediate**

6. Given an array where all elements appear twice except one, find the unique element.
7. Find the rightmost set bit of a number.
8. Toggle the k-th bit of a number.
9. Generate all subsets of a set using bitmasking.
10. Convert a number to its binary representation without using `bin()`.

### **Level 3: Advanced**

11. Implement XOR-swap algorithm on an array of numbers.
12. Generate n-bit Gray code sequence.
13. Solve problems like “count numbers with exactly k set bits between 1 and N”.
14. Find two numbers appearing once in an array where all others appear twice.
15. Solve problems using bitmask DP (for combinatorial subset problems).

---

## ✅ **Tips for Muscle Memory**

1. **Do not rely on built-in functions** for the first month.
2. **Write binary representations** on paper for all problems.
3. **Practice every operator** individually before combining.
4. **Solve small problems multiple times** to internalize tricks.
5. **Always think in bits, not decimal**.

---

Bitwise Operations Drill Set (50 Questions)
Level 1: Binary Basics (1–10)

Write the 8-bit binary of: 5, 12, 23, 60.

Convert these 8-bit binaries to decimal: 1010, 1111, 0101, 1001.

Write the 8-bit binary of 0, 1, 2, 3, 4, 7, 15, 31.

Identify the LSB (least significant bit) of: 5, 10, 23, 44.

Identify the MSB (most significant bit) of: 5, 12, 20, 60.

Which numbers have all bits 1 in 3-bit representation?

Which numbers have only one bit set between 0–15?

Convert 13 to binary and identify the positions of set bits.

Convert 22 to binary and identify the positions of unset bits.

For n = 19 (10011), how many 1s and 0s?

Level 2: AND, OR, XOR (11–20)

Compute 5 & 3. Show binary and decimal.

Compute 5 | 3.

Compute 5 ^ 3.

Compute 12 & 10.

Compute 12 | 10.

Compute 12 ^ 10.

Compute 7 & 15.

Compute 7 | 15.

Compute 7 ^ 15.

Compute (6 ^ 3) & 5.

Level 3: NOT & Bit Flipping (21–25)

Compute ~5 for 8-bit numbers. Show binary and decimal (consider 2’s complement).

Compute ~12.

Compute ~0.

Flip all bits of 10101010.

Flip all bits of 11110000.

Level 4: Shifts (26–33)

Compute 5 << 1. Show binary and decimal.

Compute 3 << 2.

Compute 12 << 3.

Compute 20 >> 1.

Compute 20 >> 2.

Compute 40 >> 3.

For n = 7 (0111), compute n << 2.

For n = 15 (1111), compute n >> 3.

Level 5: Bit Tricks (34–42)

Find the rightmost set bit of n = 12 (n & -n).

Find the rightmost set bit of n = 10.

Turn off the rightmost set bit of n = 14.

Turn off the rightmost set bit of n = 21.

Check if n = 16 is power of 2 using n & (n-1).

Check if n = 18 is power of 2.

Count set bits in n = 7.

Count set bits in n = 15.

Count set bits in n = 19.

Level 6: Set, Clear, Toggle Bits (43–46)

For n = 9 (1001), set 2nd bit.

For n = 9, clear 3rd bit.

For n = 9, toggle 0th bit.

For n = 9, toggle 1st and 3rd bits.

Level 7: XOR Patterns & Mental Tricks (47–50)

Compute mentally: 5 ^ 5, 0 ^ 12, 7 ^ 3 ^ 3, 6 ^ 1 ^ 6.

Compute (a ^ b) ^ b for a=10, b=7. Explain the result.

Compute a ^ 0 for a = 15, 23, 42. Observe the pattern.

Convert numbers 0,1,2,3 to 2-bit Gray code using n ^ (n >> 1).

✅ How to use this drill set effectively:

Always write numbers in binary first.

Perform operations bit by bit.

Convert the result to decimal to verify correctness.

Repeat multiple times until you can do it mentally.

For shifts, also observe patterns in decimal (doubling/halving, etc.).

